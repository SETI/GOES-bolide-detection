#*************************************************************************************************************
# This file contains a class "GlintFilter" to be used to filter out glint regions from GLM data. See the __main__
# function for an example application.
#
# This class utilizes a look-up table of glint points generated by the script glint_spot.py.
#
# Usage steps:
#
#   1) Identify the glint lookup tables G17GlintLookupTableFilename G17GlintLookupTableFilename
#
#   2) Instantiate a glint filter object
#       glintObj = GlintFilter(G16GlintLookupTableFilename, G17GlintLookupTableFilename, glintRegionRadiusDegrees)
#
#   3) Call the filter on all time/lat/long coordinates to test:
#       withinGlintRegion = glintObj.glint_filter(platform_ID, julianDay, latitudeDegrees, longitudeDegrees)
#
#       withinGlintRegion Will be a logical array indicating which test points are withing the glint region
#
#*************************************************************************************************************

import numpy as np
import traceback
import sys
import csv
import argparse
import netCDF4
import bolide_detections as bd
import datetime
from astropy.time import Time
import os
import geometry_utilities as geoUtil

#*************************************************************************************************************
# This file contains a class "GlintFilter" to be used to filter out glint regions from GLM data
#
#*************************************************************************************************************

class GlintFilter:


#*************************************************************************************************************
# Constructor
#   
# Constructs a glint filter object. Initiates by loading the glint lookup table from file.
#
# Inputs:
#   G16GlintLookupTableFilename     -- [str] filename and path to the GOES 16 lookup table
#   G17GlintLookupTableFilename     -- [str] filename and path to the GOESD 17 lookup table
#   glintRegionG16LatRadiusDegrees  -- [float] GOES-16 size of glint region circle in degrees latitude
#   glintRegionG16LonRadiusDegrees  -- [float] GOES-16 size of glint region circle in degrees longitude
#   glintRegionG17LatRadiusDegrees  -- [float] GOES-17 size of glint region circle in degrees latitude
#   glintRegionG17LonRadiusDegrees  -- [float] GOES-17 size of glint region circle in degrees longitude
#   verbosity                       -- [bool] 
#
# INSTANCE ATTRIBUTES
#   glintRegionG16LatRadiusDegrees  -- [float] GOES-16 size of glint region circle in degrees latitude
#   glintRegionG16LonRadiusDegrees  -- [float] GOES-16 size of glint region circle in degrees longitude
#   glintRegionG17LatRadiusDegrees  -- [float] GOES-17 size of glint region circle in degrees latitude
#   glintRegionG17LonRadiusDegrees  -- [float] GOES-17 size of glint region circle in degrees longitude
#   G16GlintLookupTable         -- [dictionary] Contains the GOES 16 lookup table with the following three key labels:
#       'julianDay'
#       'latitudeDegrees'
#       'longitudeDegrees'
#   G17GlintLookupTable         -- [dictionary] Contains the GOES 17 lookup table with the following three key labels:
#       'julianDay'
#       'latitudeDegrees'
#       'longitudeDegrees'
#   G16TableAvailable           --[logical] If true then the lookup table is available for GOES 16
#   G17TableAvailable           --[logical] If true then the lookup table is available for GOES 17
#
#*************************************************************************************************************
    def __init__(self, G16GlintLookupTableFilename, G17GlintLookupTableFilename, 
                    glintRegionG16LatRadiusDegrees, glintRegionG16LonRadiusDegrees, 
                    glintRegionG17LatRadiusDegrees, glintRegionG17LonRadiusDegrees, verbosity=False):

        raise Exception('Modify this for use with G18 and G19')

        self.glintRegionG16LatRadiusDegrees = glintRegionG16LatRadiusDegrees
        self.glintRegionG16LonRadiusDegrees = glintRegionG16LonRadiusDegrees
        self.glintRegionG17LatRadiusDegrees = glintRegionG17LatRadiusDegrees
        self.glintRegionG17LonRadiusDegrees = glintRegionG17LonRadiusDegrees
 
        # Parse the lookup tables
        [self.G16GlintLookupTable, self.G16TableAvailable]  = self.read_lookup_table(G16GlintLookupTableFilename, verbosity)
        [self.G17GlintLookupTable, self.G17TableAvailable]  = self.read_lookup_table(G17GlintLookupTableFilename, verbosity)

        # Check which lookup tables are available
        if (not self.G16TableAvailable):
            if verbosity:
                print('No lookup table for GOES 16. Glint Filter will be disabled for GOES 16.')
        if (not self.G17TableAvailable):
            if verbosity:
                print('No lookup table for GOES 17. Glint Filter will be disabled for GOES 17.')

#*************************************************************************************************************
# def glint_filter (goesSatellite, julianDay, latitudeDegrees, longitudeDegrees)
#
# Deterimes which events, given by the Julian Date, latitude and longitude are within a glint region as defined by the
# supplied glint lookup table
#
# Inputs:
#   goesSatellite       -- [str] which GOES satellite to lookup {'G16' 'G17'}
#   julianDay           -- [float list] list of julian days to look up
#   latitudeDegrees     -- [float list] list of latitude to look up
#   longitudeDegrees    -- [float list] list of longitude to look up
#
# Outputs:
#   isInGlintRegion     -- [logical list] Which test points are within the glint region
#
#*************************************************************************************************************
    def glint_filter (self, goesSatellite, julianDay, latitudeDegrees, longitudeDegrees, verbosity=False):

        # Make sure proper input was given
        nDatums = np.size(julianDay)
        if ( (np.size(latitudeDegrees) != nDatums) or (np.size(longitudeDegrees) != nDatums) ):
            print('glint_filter: time, lat and long must be same length')
            print('-'*60)
            traceback.print_exc(file=sys.stdout)
            print('-'*60)
            sys.exit('Configuration Error')
 
        # Determine the satellite to look up
        if goesSatellite == 'G16':
            if (not self.G16TableAvailable):
                if verbosity:
                    print('WARNING: Glint Filter disabled for GOES 16! No filtering occured!')
                return np.full(nDatums, False)
            else:
                lookupTable = self.G16GlintLookupTable
                glintRegionLatRadiusDegrees = self.glintRegionG16LatRadiusDegrees 
                glintRegionLonRadiusDegrees = self.glintRegionG16LonRadiusDegrees 
        elif goesSatellite == 'G17':
            if (not self.G17TableAvailable):
                if verbosity:
                    print('WARNING: Glint Filter disabled for GOES 17! No filtering occured!')
                return np.full(nDatums, False)
            else:
                lookupTable = self.G17GlintLookupTable
                glintRegionLatRadiusDegrees = self.glintRegionG17LatRadiusDegrees 
                glintRegionLonRadiusDegrees = self.glintRegionG17LonRadiusDegrees 
        else:
            print('glint_filter: Unknown GOES Satellite string')
            print('-'*60)
            traceback.print_exc(file=sys.stdout)
            print('-'*60)
            sys.exit('Configuration Error')

        #***
        # Everything looks good, now do the filtering

        # Sort data into chronological order
        sortOrder = np.argsort(julianDay)
        reverseSortOrder = np.argsort(sortOrder) # To reverse the sorting
        julianDay = julianDay[sortOrder]
        latitudeDegrees = latitudeDegrees[sortOrder]
        longitudeDegrees = longitudeDegrees[sortOrder]
 
        # If we force julianDay and the lookup table to be in chronological order then we can speed up the lookup
        # process by sequentially working through the list
        # Also, all the data will come from a small chunk of the full lookup table. So bracket the lookup table with the
        # data
        minLookupIndex = np.argmin(np.abs(julianDay[0]-lookupTable['julianDay']))
        maxLookupIndex = np.argmin(np.abs(julianDay[-1]-lookupTable['julianDay'])) + 1
        lookupTableIndex = minLookupIndex # Marker for current location in lookup table

        nearestLookupIndex = np.zeros(np.size(julianDay), dtype=int)
        for i in np.arange(np.size(julianDay)):
            # Search from marker index to end of lookup table
            nearestLookupIndex[i] = lookupTableIndex + np.argmin(np.abs(julianDay[i]-lookupTable['julianDay'][lookupTableIndex:maxLookupIndex]))
            lookupTableIndex = nearestLookupIndex[i]
        
 
        # The glint region is defined by the two ellipsoidal-like radii

        # First get the angular distance and bearing from the glint centroid to the point
        distanceFromGlint = geoUtil.DistanceFromLatLonPoints( lookupTable['latitudeDegrees'][nearestLookupIndex], 
                                        lookupTable['longitudeDegrees'][nearestLookupIndex],
                                        latitudeDegrees, longitudeDegrees, sphereRadius=180.0/np.pi)

        bearingFromGlint = geoUtil.BearingFromLatLon ( lookupTable['latitudeDegrees'][nearestLookupIndex], 
                                        lookupTable['longitudeDegrees'][nearestLookupIndex],
                                        latitudeDegrees, longitudeDegrees)

        # Now compute the radius of the ellipse in this bearing direction
        ellipseAngularDist = geoUtil.RadiusAlongEllipse (glintRegionLatRadiusDegrees, glintRegionLonRadiusDegrees, bearingFromGlint)

        # Locations where the lookupTable lat or lon is nan, isInGlintRegion returns False 
        isInGlintRegion = distanceFromGlint < ellipseAngularDist

        # Reverse the sorting to get back to the original input data order
        return isInGlintRegion[reverseSortOrder]


#*************************************************************************************************************
# Static method to load in the lookup table information into a dictionary
#
# Inputs:
#   filename    -- [str] filename and path to the lookup table file
#   verbosity                       -- [bool] 
#
# Outputs:
#   lookupTable  -- [dictionary] Contains the lookup table with the following three key labels:
#       'julianDay'
#       'latitudeDegrees'
#       'longitudeDegrees'
#   success     -- [logical] If true then lookup table was sucessfully loaded
#
#*************************************************************************************************************
    @staticmethod
    def read_lookup_table (filename, verbosity):
    
        success = False

        lookupTable = {'julianDay':[], 'latitudeDegrees':[], 'longitudeDegrees':[]}

        if (os.path.exists(filename)): 
            with open(filename, 'r') as fp:
                reader = csv.reader(fp)
                try:
                    for row in reader:
                        # Check first row of CSV file.
                        if row.__contains__('JulianDay') :
                            julianDay           = row.index('JulianDay')
                            latitudeDegrees     = row.index('Latitude')
                            longitudeDegrees    = row.index('Longitude')
                        else:
                            lookupTable['julianDay'].append(float(row[julianDay]))
                            lookupTable['latitudeDegrees'].append(float(row[latitudeDegrees]))
                            lookupTable['longitudeDegrees'].append(float(row[longitudeDegrees]))
                    success = True
            
                except csv.Error as e:
                    sys.exit('file %s, line %d: %s' % (csvFileName, reader.line_num, e))
        else:
            if verbosity:
                print('File {} does not exist. Glint filter disabled.'.format(filename))

        # Convert to ndarrays
        lookupTable['julianDay']        = np.array(lookupTable['julianDay'])
        lookupTable['latitudeDegrees']  = np.array(lookupTable['latitudeDegrees'])
        lookupTable['longitudeDegrees'] = np.array(lookupTable['longitudeDegrees'])

        # Convert inf to NaN so that numpy does not report RuntimeWarning
        infHere = np.nonzero(np.isinf(lookupTable['latitudeDegrees']))[0]
        lookupTable['latitudeDegrees'][infHere] = np.nan
        infHere = np.nonzero(np.isinf(lookupTable['longitudeDegrees']))[0]
        lookupTable['longitudeDegrees'][infHere] = np.nan

        # Make sure lookup tables are in chronological order
        sortOrder = np.argsort(lookupTable['julianDay'])
        lookupTable['julianDay'] = lookupTable['julianDay'][sortOrder]
        lookupTable['latitudeDegrees']  = lookupTable['latitudeDegrees'][sortOrder]
        lookupTable['longitudeDegrees']  = lookupTable['longitudeDegrees'][sortOrder]

        return lookupTable, success


# END class GlintFilter

#*************************************************************************************************************
# Testing tool
#
# Command line inputs:
# glint_filter (-G16 G16_lookup_table_file -G17 G17_lookup_table_file -tf test_GOES_data_file)
#
#*************************************************************************************************************

if __name__ == "__main__":
    
    # Set glint region radius to 5 degrees
    glintRegionG16LatRadiusDegrees = 5.0
    glintRegionG16LonRadiusDegrees = 50.0
    glintRegionG17LatRadiusDegrees = 50.0
    glintRegionG17LonRadiusDegrees = 5.0

    # Parse command line arguments
    parser = argparse.ArgumentParser(description=
            'glint_filter: Determines which test coordinates are within a glitn region')
    parser.add_argument('--G16_filename', '-G16', dest='G16GlintLookupTableFilename',     
        type=str, default='',
        help='The path to a file containing the G16 glint lookup table')
    parser.add_argument('--G17_filename', '-G17', dest='G17GlintLookupTableFilename',     
        type=str, default='',
        help='The path to a file containing the G17 glint lookup table')
    parser.add_argument('--test_file', '-tf', dest='testFilename', 
        type=str, default='',
        help = 'The GOES data file to run the filter on')

    args = parser.parse_args(sys.argv[1:])
    
    # Instantiate a glint filter object
    glintObj = GlintFilter(args.G16GlintLookupTableFilename, args.G17GlintLookupTableFilename, 
                            glintRegionG16LatRadiusDegrees, glintRegionG16LonRadiusDegrees,
                            glintRegionG17LatRadiusDegrees, glintRegionG17LonRadiusDegrees)

    # Read in the test data
    nc4Data = netCDF4.Dataset(args.testFilename)
    productTime = bd.bolideDetection.epoch + datetime.timedelta( seconds=int(nc4Data.variables['product_time'][0].data) )
    group_time_offset   = np.array(nc4Data.variables['group_time_offset'][:].data)
    latitudeDegrees     = np.array(nc4Data.variables['group_lat'][:].data)
    longitudeDegrees    = np.array(nc4Data.variables['group_lon'][:].data)
    platform_ID         = nc4Data.platform_ID
    nc4Data.close()

    # Compute Julian Date for each group
    julianDay = []
    if productTime > datetime.datetime(2018, 10, 15, 16, 0): # nc file format changed and group_time_offset is in fractions of second
        millisecondFactor = 1000.0
    else: # nc file old format and group_time_offset is in milliseconds
        millisecondFactor = 1.0

    for i in range( len(group_time_offset) ):
        # Add in the offset to the product time to get the time for each event in datetime format
        timeThisGroup = productTime + datetime.timedelta( milliseconds=int(group_time_offset[i]*millisecondFactor) )
        # Convert to astropy time object in julian date format
        julianDay.append(Time(timeThisGroup).jd)

    julianDay = np.array(julianDay)
    
    # Run on the test data
    withinGlintRegion = glintObj.glint_filter(platform_ID, julianDay, latitudeDegrees, longitudeDegrees)

    print('-'*60)
    print('Glint Filter unit test ran to completion')
    print('-'*60)
